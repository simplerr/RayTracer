#version 450

/*
	http://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection
	https://github.com/LWJGL/lwjgl3-wiki/wiki/2.6.2.-Ray-tracing-with-OpenGL-Compute-Shaders-%28Part-II%29
	http://ray-tracing-conept.blogspot.se/2015/01/ray-box-intersection-and-normal.html

	https://www.ics.uci.edu/~gopi/CS211B/RayTracing%20tutorial.pdf
	http://www.flipcode.com/archives/Raytracing_Topics_Techniques-Part_1_Introduction.shtml
*/

uniform float time;

layout(binding = 0, rgba8) uniform image2D framebuffer;

layout (local_size_x = 16, local_size_y = 16) in;

uniform vec3 eye;
uniform vec3 ray00;
uniform vec3 ray01;
uniform vec3 ray10;
uniform vec3 ray11;

// Light source
struct Light {
	vec3 position;
	vec3 direction;
	vec3 color;
};

struct Box {
	vec3 min;
	vec3 max;
	vec3 material;
};

struct Sphere {
	vec3 center;
	vec3 material;
	float radius;
};

#define NUM_BOXES 5
#define NUM_SPHERES 4
#define NUM_LIGHTS 1
#define MAX_SCENE_BOUNDS 100000.0
#define TRACE_DEPTH 1

float side = 50.0;

const Box boxes[] = {
	{vec3(0, -0.1, 0), vec3(side, 0.0, side), vec3(0.5, 0.5, 0)},
	{vec3(0, side , 0), vec3(side, side-0.1, side), vec3(0, 0.5, 0)},
	{vec3(-0.1, 0, 0), vec3(0, side, side), vec3(0, 0.5, 0.5)},
	{vec3(side, 0, 0), vec3(side-0.1, side, side), vec3(0.5, 0.5, 0.5)},
	{vec3(0, 0, -0.1), vec3(side, side, 0), vec3(0.5, 0, 0)},
};

const Sphere spheres[] = {
	{vec3(1, 8, 1), vec3(1, 0, 0), 1},
	{vec3(1, 4, 1), vec3(0, 1, 0), 2},
	{vec3(1, 11, 1), vec3(0, 0, 1), 0.5},
	{vec3(3, 7, 3), vec3(0, 1, 1), 0.5}
};

const Light lights[] = {
	{vec3(-20, 20, -20), vec3(1, -1, 1), vec3(1, 1, 1)},
	{vec3(0, 50, 0), vec3(1, 0, 0), vec3(1, 1, 1)}
};

struct hitinfo {
	vec2 lambda;
	int index;
	int type;			// 0 = sphere, 1 = box
	vec3 intersection;
	vec3 normal;
	vec3 eyeDirection;
	vec3 material;
};

vec2 intersectBox(vec3 origin, vec3 dir, const Box b) {
	vec3 tMin = (b.min - origin) / dir;
	vec3 tMax = (b.max - origin) / dir;
	vec3 t1 = min(tMin, tMax);
	vec3 t2 = max(tMin, tMax);
	float tNear = max(max(t1.x, t1.y), t1.z);
	float tFar = min(min(t2.x, t2.y), t2.z);
	return vec2(tNear, tFar);
}

// Calculates the normal at the intersection point between a ray and a box
vec3 calculateBoxNormal(vec3 hitpoint, int box_index)
{
	vec3 normal;
	vec3 localPoint = hitpoint - boxes[box_index].min;
	float min = 9999;
	vec3 extents = boxes[box_index].max - boxes[box_index].min;

	float dist = abs(extents.x - localPoint.x);
	if(dist < min)
	{
		min = dist;
		normal = sign(localPoint.x) * vec3(1, 0, 0);
	}

	dist = abs(extents.y - localPoint.y);
	if(dist < min)
	{
		min = dist;
		normal = sign(localPoint.y) * vec3(0, 1, 0);
	}

	dist = abs(extents.z - localPoint.z);
	if(dist < min)
	{
		min = dist;
		normal = sign(localPoint.z) * vec3(0, 0, 1);
	}

	return normal;
}

bool intersectBoxes(vec3 origin, vec3 dir, out hitinfo info) {
	info.lambda = vec2(MAX_SCENE_BOUNDS, MAX_SCENE_BOUNDS);
	float closest = MAX_SCENE_BOUNDS;
	bool found = false;
	for (int i = 0; i < NUM_BOXES; i++) {
		vec2 lambda = intersectBox(origin, dir, boxes[i]);
		if (lambda.x > 0.0 && lambda.x < lambda.y && lambda.x < closest) {
			// Calculate hit information
			info.lambda = lambda;
			info.index = i;
			info.intersection = origin + dir * info.lambda.x;
			info.normal = calculateBoxNormal(info.intersection, info.index);
			info.material = boxes[i].material;
			info.type = 1;
			info.eyeDirection = normalize(info.intersection - eye);

			closest = lambda.x;
			found = true;
		}
	}
	return found;
}

bool intersectSpheres(vec3 origin, vec3 dir, out hitinfo info) {
	info.lambda = vec2(MAX_SCENE_BOUNDS, MAX_SCENE_BOUNDS);
	float closest = MAX_SCENE_BOUNDS;
	bool found = false;
	for (int i = 0; i < NUM_SPHERES; i++) 
	{
		float t0, t1;

		// geometric solution
        vec3 L = spheres[i].center - origin; 
        float tca = dot(L, dir); 
        if (tca < 0) 
			continue;

        float d2 = dot(L, L) - tca * tca; 

        if (d2 > pow(spheres[i].radius, 2)) 
			continue;

        float thc = sqrt(pow(spheres[i].radius, 2) - d2); 
        t0 = tca - thc; 
        t1 = tca + thc; 

		if(t0 < 0)
		{
			float tmp = t0;
			t0 = t1;
			t1 = tmp;

			if(t0 < 0)
				continue;
		}

		// Is it the closest sphere?
		if(t0 > 0.0 && t0 < t1 && t0 < closest) {
			// Calculate hit information
			info.lambda = vec2(t0, t1);
			info.index = i;
			info.intersection = origin + dir * info.lambda.x;
			info.normal = normalize(info.intersection - spheres[info.index].center);
			info.eyeDirection = normalize(info.intersection - eye);
			info.material = spheres[info.index].material;
			info.type = 0;

			// Update the closest distance
			closest = t0;
		}

		found = true;
	}

	return found;
}

bool closestObjectIntersection(vec3 origin, vec3 dir, out hitinfo info)
{
	// Check intersection with spheres
	hitinfo sphereInfo;
	bool sphereIntersection = intersectSpheres(origin, dir, sphereInfo);

	// Check intersection with boxes
	hitinfo boxInfo;
	bool boxIntersection = intersectBoxes(origin, dir, boxInfo);

	// No intersection
	if(!sphereIntersection && !boxIntersection)
		return false;

	// A sphere is closest
	if(sphereInfo.lambda.x < boxInfo.lambda.x)
	{
		info = sphereInfo;
		return true;
	}
	// A box is closest
	else if(boxInfo.lambda.x < sphereInfo.lambda.x)
	{
		info = boxInfo;
		return true;
	}
}

vec4 trace(vec3 origin, vec3 dir) {
	hitinfo intersectInfo;

	dir = normalize(dir);

	vec3 finalColor = vec3(0, 0, 0);
	float frac = 1.0;

	// Get first sphere intersecting the ray
	for(int bounce = 0; bounce < TRACE_DEPTH; bounce++)
	{
		if(closestObjectIntersection(origin, dir, intersectInfo)) 
		{
			// Ambient factor
			vec3 color = vec3(0, 0, 0);	

			for(int i = 0; i < NUM_LIGHTS; i++)
			{
				vec3 ambient = vec3(0.2);//0.1, 0.1, 0.1);
				vec3 diffuse = vec3(0.0, 0.0, 0.0);
				vec3 specular = vec3(0.0, 0.0, 0.0);
				float shadowFactor = 1;

				vec3 lightDirection = lights[i].position - intersectInfo.intersection;
				lightDirection = normalize(lightDirection);

				// Shadow component
				hitinfo tmpIntersectInfo;
				if(closestObjectIntersection(intersectInfo.intersection + lightDirection*1, lightDirection, tmpIntersectInfo))
				{
					// Shadowed
					//ambient = vec3(0, 0, 0);
					shadowFactor = 0.2;
				}
		
				// Diffuse component
				float diffuseFactor = dot(intersectInfo.normal, -lights[i].direction);

				if(diffuseFactor < 0)
					diffuse = vec3(0, 0, 0);					
				else
					diffuse = diffuseFactor * lights[i].color * intersectInfo.material;

				// Specular component
				specular = vec3(0, 0, 0);
				if(diffuseFactor < 0.0)
					specular = vec3(0, 0, 0);
				else
					specular = pow(max(0.0, dot(reflect(-lights[i].direction, intersectInfo.normal), intersectInfo.eyeDirection)), 0.5f) * 0.05 * lights[i].color * intersectInfo.material;		// 0.05 is the constant intensity

				color += clamp(ambient * intersectInfo.material + diffuse + specular, 0.0, 1.0) * shadowFactor;
				finalColor += color * frac;		
				frac *= 1;
			}

			//return vec4(color, 1.0f);		
		}

		// Calculate the reflection ray
		// Used in the next iteration
		float c1 = -dot(intersectInfo.normal, dir);
		dir = dir + (2*intersectInfo.normal*c1);
		origin = intersectInfo.intersection ;
		
	}	// for TRACE_DEPTH

	return vec4(finalColor, 1.0);
	return vec4(0.3, 0.3, 0.3, 1.0);
}

void main(void) {
	ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
	ivec2 size = imageSize(framebuffer);
	if (pix.x >= size.x || pix.y >= size.y) {
		return;
	}

	vec2 pos = vec2(pix) / vec2(size.x, size.y);
	vec3 dir = mix(mix(ray00, ray01, pos.y), mix(ray10, ray11, pos.y), pos.x);

	vec4 color = trace(eye, dir);

	imageStore(framebuffer, pix, color);
}